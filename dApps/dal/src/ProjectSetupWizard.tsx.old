import React, { useState, useEffect, useCallback } from 'react';
import { dvreROCrateClient, DALROCrate, DALConfiguration, DALDataset, DALWorkflow, DALModel } from './DVREROCrateClient';
import { cwlManager, ALConfiguration } from './CWLManager';
import { orchestrationAPI } from './OrchestrationAPI';

interface ProjectSetupWizardProps {
  projectId: string;
  projectData: any; // DVRE project data from smart contract
  userWallet: string;
  onComplete: (roCrate: DALROCrate) => void;
  onCancel: () => void;
}

interface DatasetConfig {
  name: string;
  description: string;
  file?: File;
  url?: string;
  ipfsHash?: string;
  columns: Array<{
    name: string;
    dataType: 'string' | 'number' | 'boolean' | 'date';
    description: string;
  }>;
}

interface ModelConfig {
  name: string;
  algorithm: 'logistic_regression' | 'neural_network' | 'random_forest' | 'svm';
  parameters: Record<string, any>;
}

interface WorkflowConfig {
  name: string;
  description: string;
  customCWL?: string;
  useTemplate: boolean;
}

type SetupStep = 'datasets' | 'model' | 'workflow' | 'configuration' | 'review';

export const ProjectSetupWizard: React.FC<ProjectSetupWizardProps> = ({
  projectId,
  projectData,
  userWallet,
  onComplete,
  onCancel
}) => {
  const [currentStep, setCurrentStep] = useState<SetupStep>('datasets');
  const [roCrate, setRoCrate] = useState<DALROCrate | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Step-specific state
  const [datasetConfigs, setDatasetConfigs] = useState<DatasetConfig[]>([]);
  const [modelConfig, setModelConfig] = useState<ModelConfig>({
    name: '',
    algorithm: 'logistic_regression',
    parameters: {}
  });
  const [workflowConfig, setWorkflowConfig] = useState<WorkflowConfig>({
    name: '',
    description: '',
    useTemplate: true
  });
  const [alConfig, setALConfig] = useState<Partial<DALConfiguration>>({
    queryStrategy: 'uncertainty_sampling',
    labelingBudget: 100,
    maxIterations: 10
  });

  // Initialize RO-Crate from DVRE
  const initializeROCrate = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);

      // Try to get existing DAL RO-Crate from DVRE
      let existingROCrate = await dvreROCrateClient.getDALROCrate(projectId);
      
      if (existingROCrate) {
        // Load existing configuration into the wizard
        setRoCrate(existingROCrate);
        
        // Populate form fields from existing RO-Crate
        if (existingROCrate.alConfig) {
          setALConfig(existingROCrate.alConfig);
        }
        
        if (existingROCrate.datasets && existingROCrate.datasets.length > 0) {
          const configs = existingROCrate.datasets.map(dataset => ({
            name: dataset.name,
            description: dataset.description || '',
            ipfsHash: dataset.ipfsHash,
            columns: (dataset.columns || []).map(col => ({
              name: col.name,
              dataType: col.dataType,
              description: col.description || '' // Ensure description is always a string
            }))
          }));
          setDatasetConfigs(configs);
        }
        
        if (existingROCrate.workflow) {
          setWorkflowConfig({
            name: existingROCrate.workflow.name,
            description: existingROCrate.workflow.description || '',
            customCWL: existingROCrate.workflow.cwlContent,
            useTemplate: !existingROCrate.workflow.cwlContent
          });
        }
        
        console.log('DAL: Loaded existing RO-Crate configuration');
      } else {
        // Initialize new DAL configuration in DVRE
        existingROCrate = await dvreROCrateClient.updateDALConfiguration(projectId, {
          queryStrategy: 'uncertainty_sampling',
          labelingBudget: 100,
          maxIterations: 10,
          modelConfig: {
            model_type: 'logistic_regression',
            parameters: {}
          },
          dataConfig: {
            trainingDataset: '',
            features: []
          }
        });
        
        if (existingROCrate) {
          setRoCrate(existingROCrate);
          console.log('DAL: Initialized new RO-Crate configuration');
        }
      }
    } catch (error) {
      console.error('DAL: Failed to initialize RO-Crate:', error);
      setError('Failed to load project configuration');
    } finally {
      setLoading(false);
    }
  }, [projectId]);

  // Initialize on component mount
  useEffect(() => {
    initializeROCrate();
  }, [initializeROCrate]);

  const updateROCrate = useCallback(async (updater: (crate: DALROCrate) => Promise<DALROCrate>) => {
    if (roCrate) {
      try {
        setLoading(true);
        setError(null);
        const updated = await updater(roCrate);
        setRoCrate(updated);
        // Note: The updater should handle the DVRE API calls directly
        console.log('DAL: RO-Crate updated successfully');
      } catch (error: any) {
        console.error('DAL: Failed to update RO-Crate:', error);
        setError(`Failed to update project configuration: ${error.message}`);
      } finally {
        setLoading(false);
      }
    }
  }, [roCrate, projectId]);

  // Handle dataset upload (simplified version)
  const handleDatasetUpload = useCallback(async (file: File, type: 'training' | 'labeling') => {
    if (!roCrate) return;

    try {
      setLoading(true);
      setError(null);

      // Simulate IPFS upload (replace with actual IPFS upload in production)
      const mockIpfsHash = `Qm${Math.random().toString(36).substr(2, 44)}`;
      const mockUrl = `https://ipfs.io/ipfs/${mockIpfsHash}`;

      const datasetInfo: DALDataset = {
        name: file.name,
        description: type === 'training' ? 'Training dataset' : 'Labeling dataset',
        type: type,
        format: 'csv',
        url: mockUrl,
        ipfsHash: mockIpfsHash,
        size: file.size,
        columns: [] // Will be populated when file is processed
      };

      // Add dataset using DVRE client
      const updatedROCrate = await dvreROCrateClient.addDataset(projectId, datasetInfo);
      if (updatedROCrate) {
        setRoCrate(updatedROCrate);
        console.log(`DAL: ${type} dataset uploaded successfully`);
      }
    } catch (error: any) {
      console.error('DAL: Dataset upload failed:', error);
      setError(`Failed to upload ${type} dataset: ${error.message}`);
    } finally {
      setLoading(false);
    }
  }, [roCrate, projectId]);

  // Generate workflow (simplified version)
  const generateWorkflow = useCallback(async () => {
    if (!roCrate) return;

    try {
      setLoading(true);
      setError(null);

      const cwlWorkflow = cwlManager.createALTemplate(
        projectId,
        workflowConfig.name || 'DAL Workflow',
        alConfig as ALConfiguration
      );

      const workflowInfo: DALWorkflow = {
        name: workflowConfig.name || 'DAL Workflow',
        description: workflowConfig.description || 'Generated Active Learning workflow',
        programmingLanguage: 'cwl',
        steps: ['train', 'query', 'label', 'evaluate'],
        cwlContent: workflowConfig.customCWL || cwlWorkflow.content,
        inputs: cwlWorkflow.inputs,
        outputs: cwlWorkflow.outputs
      };

      // Add workflow using DVRE client
      const updatedROCrate = await dvreROCrateClient.addWorkflow(projectId, workflowInfo);
      if (updatedROCrate) {
        setRoCrate(updatedROCrate);
        console.log('DAL: Workflow generated successfully');
      }

      // Also add model configuration
      const modelInfo: DALModel = {
        name: modelConfig.name || 'DAL Model',
        algorithm: modelConfig.algorithm,
        parameters: modelConfig.parameters
      };

      const finalROCrate = await dvreROCrateClient.addModel(projectId, modelInfo);
      if (finalROCrate) {
        setRoCrate(finalROCrate);
        console.log('DAL: Model configuration added successfully');
      }
    } catch (error: any) {
      console.error('DAL: Workflow generation failed:', error);
      setError(`Failed to generate workflow: ${error.message}`);
    } finally {
      setLoading(false);
    }
  }, [roCrate, projectId, workflowConfig, alConfig, modelConfig]);

  // Finalize project (simplified version using DVRE finalization)
  const finalizeProject = useCallback(async () => {
    if (!roCrate) return;

    try {
      setLoading(true);
      setError(null);

      console.log('Starting project finalization...');

      // Update AL configuration first
      await dvreROCrateClient.updateDALConfiguration(projectId, alConfig);

      // Use DVRE's finalization process
      const finalizationResult = await dvreROCrateClient.finalizeProject(
        projectId,
        projectData.address
      );

      console.log('Project finalized successfully:', finalizationResult);

      if (finalizationResult.success) {
        // Update local state
        const finalizedROCrate = await dvreROCrateClient.getDALROCrate(projectId);
        if (finalizedROCrate) {
          setRoCrate(finalizedROCrate);
          onComplete(finalizedROCrate);
        }
      }
    } catch (error: any) {
      console.error('DAL: Project finalization failed:', error);
      setError(`Project finalization failed: ${error.message}`);
    } finally {
      setLoading(false);
    }
  }, [roCrate, projectId, projectData.address, alConfig, onComplete]);

  const renderDatasetsStep = () => (
    <div className="setup-step">
      <h3>Project Datasets</h3>
      <p>Upload or link your training and labeling datasets for the Active Learning project.</p>
      
      <div className="dataset-section">
        <h4>Training Dataset</h4>
        <div className="form-group">
          <label>Dataset Name:</label>
          <input
            type="text"
            value={datasetConfigs[0]?.name || ''}
            onChange={(e) => setDatasetConfigs(prev => prev.map((ds, index) => 
              index === 0 ? { ...ds, name: e.target.value } : ds
            ))}
            placeholder="e.g., Medical Images Training Set"
          />
        </div>
        <div className="form-group">
          <label>Description:</label>
          <textarea
            value={datasetConfigs[0]?.description || ''}
            onChange={(e) => setDatasetConfigs(prev => prev.map((ds, index) => 
              index === 0 ? { ...ds, description: e.target.value } : ds
            ))}
            placeholder="Describe your training dataset..."
            rows={3}
          />
        </div>
        <div className="form-group">
          <label>Upload Dataset File:</label>
          <input
            type="file"
            accept=".csv,.json,.tsv"
            onChange={(e) => {
              const file = e.target.files?.[0];
              if (file) handleDatasetUpload(file, 'training');
            }}
          />
        </div>
        {roCrate?.datasets.training && (
          <div className="dataset-preview">
            ✓ Training dataset configured: {roCrate.datasets.training.name}
          </div>
        )}
      </div>

      <div className="dataset-section">
        <h4>Labeling Dataset (Optional)</h4>
        <div className="form-group">
          <label>Dataset Name:</label>
          <input
            type="text"
            value={datasetConfigs[1]?.name || ''}
            onChange={(e) => setDatasetConfigs(prev => prev.map((ds, index) => 
              index === 1 ? { ...ds, name: e.target.value } : ds
            ))}
            placeholder="e.g., Unlabeled Samples for Annotation"
          />
        </div>
        <div className="form-group">
          <label>Description:</label>
          <textarea
            value={datasetConfigs[1]?.description || ''}
            onChange={(e) => setDatasetConfigs(prev => prev.map((ds, index) => 
              index === 1 ? { ...ds, description: e.target.value } : ds
            ))}
            placeholder="Describe your labeling dataset..."
            rows={3}
          />
        </div>
        <div className="form-group">
          <label>Upload Dataset File:</label>
          <input
            type="file"
            accept=".csv,.json,.tsv"
            onChange={(e) => {
              const file = e.target.files?.[0];
              if (file) handleDatasetUpload(file, 'labeling');
            }}
          />
        </div>
        {roCrate?.datasets.labeling && (
          <div className="dataset-preview">
            ✓ Labeling dataset configured: {roCrate.datasets.labeling.name}
          </div>
        )}
      </div>
    </div>
  );

  const renderModelStep = () => (
    <div className="setup-step">
      <h3>Model Configuration</h3>
      <p>Configure the machine learning model for your Active Learning project.</p>
      
      <div className="form-group">
        <label>Model Name:</label>
        <input
          type="text"
          value={modelConfig.name}
          onChange={(e) => setModelConfig(prev => ({ ...prev, name: e.target.value }))}
          placeholder="e.g., Medical Image Classifier"
        />
      </div>

      <div className="form-group">
        <label>Algorithm:</label>
        <select
          value={modelConfig.algorithm}
          onChange={(e) => setModelConfig(prev => ({ 
            ...prev, 
            algorithm: e.target.value as ModelConfig['algorithm']
          }))}
        >
          <option value="neural_network">Neural Network</option>
          <option value="logistic_regression">Logistic Regression</option>
          <option value="random_forest">Random Forest</option>
          <option value="svm">Support Vector Machine</option>
        </select>
      </div>

      {modelConfig.algorithm === 'neural_network' && (
        <div className="neural-network-config">
          <div className="form-group">
            <label>Hidden Layers (comma-separated):</label>
            <input
              type="text"
              value={modelConfig.parameters.layers?.join(', ') || '64, 32'}
              onChange={(e) => {
                const layers = e.target.value.split(',').map(l => parseInt(l.trim())).filter(l => !isNaN(l));
                setModelConfig(prev => ({
                  ...prev,
                  parameters: { ...prev.parameters, layers }
                }));
              }}
              placeholder="64, 32, 16"
            />
          </div>
          <div className="form-group">
            <label>Learning Rate:</label>
            <input
              type="number"
              step="0.0001"
              min="0.0001"
              max="1"
              value={modelConfig.parameters.learning_rate || 0.001}
              onChange={(e) => setModelConfig(prev => ({
                ...prev,
                parameters: { ...prev.parameters, learning_rate: parseFloat(e.target.value) }
              }))}
            />
          </div>
          <div className="form-group">
            <label>Batch Size:</label>
            <input
              type="number"
              min="1"
              max="512"
              value={modelConfig.parameters.batch_size || 32}
              onChange={(e) => setModelConfig(prev => ({
                ...prev,
                parameters: { ...prev.parameters, batch_size: parseInt(e.target.value) }
              }))}
            />
          </div>
        </div>
      )}

      <div className="model-preview">
        <h4>Model Summary:</h4>
        <div className="model-details">
          <div><strong>Algorithm:</strong> {modelConfig.algorithm.replace('_', ' ').toUpperCase()}</div>
          <div><strong>Parameters:</strong> {JSON.stringify(modelConfig.parameters, null, 2)}</div>
        </div>
      </div>
    </div>
  );

  const renderWorkflowStep = () => (
    <div className="setup-step">
      <h3>Workflow Configuration</h3>
      <p>Configure the CWL workflow that will orchestrate your Active Learning process.</p>
      
      <div className="form-group">
        <label>Workflow Name:</label>
        <input
          type="text"
          value={workflowConfig.name}
          onChange={(e) => setWorkflowConfig(prev => ({ ...prev, name: e.target.value }))}
          placeholder="e.g., Medical Image Active Learning Workflow"
        />
      </div>

      <div className="form-group">
        <label>Description:</label>
        <textarea
          value={workflowConfig.description}
          onChange={(e) => setWorkflowConfig(prev => ({ ...prev, description: e.target.value }))}
          placeholder="Describe your workflow..."
          rows={3}
        />
      </div>

      <div className="form-group">
        <label>
          <input
            type="checkbox"
            checked={workflowConfig.useTemplate}
            onChange={(e) => setWorkflowConfig(prev => ({ ...prev, useTemplate: e.target.checked }))}
          />
          Use DAL Template Workflow
        </label>
        <small>Generate a CWL workflow automatically based on your configuration</small>
      </div>

      {!workflowConfig.useTemplate && (
        <div className="form-group">
          <label>Custom CWL Workflow:</label>
          <textarea
            value={workflowConfig.customCWL || ''}
            onChange={(e) => setWorkflowConfig(prev => ({ ...prev, customCWL: e.target.value }))}
            placeholder="Paste your CWL workflow definition here..."
            rows={15}
            className="cwl-editor"
          />
        </div>
      )}

      {workflowConfig.useTemplate && (
        <div className="workflow-preview">
          <h4>Generated Workflow Will Include:</h4>
          <ul>
            <li>Data preprocessing and validation</li>
            <li>Initial model training on labeled data</li>
            <li>Uncertainty-based sample selection</li>
            <li>Collaborative labeling interface</li>
            <li>Model retraining with new labels</li>
            <li>Performance evaluation and reporting</li>
          </ul>
        </div>
      )}
    </div>
  );

  const renderConfigurationStep = () => (
    <div className="setup-step">
      <h3>Active Learning Configuration</h3>
      <p>Configure the Active Learning parameters for your collaborative project.</p>
      
      <div className="config-grid">
        <div className="form-group">
          <label>Query Strategy:</label>
          <select
            value={alConfig.queryStrategy}
            onChange={(e) => setALConfig(prev => ({ ...prev, queryStrategy: e.target.value }))}
          >
            <option value="uncertainty_sampling">Uncertainty Sampling</option>
            <option value="diversity_sampling">Diversity Sampling</option>
            <option value="query_by_committee">Query by Committee</option>
            <option value="expected_model_change">Expected Model Change</option>
            <option value="random_sampling">Random Sampling</option>
          </select>
        </div>

        <div className="form-group">
          <label>Labeling Budget:</label>
          <input
            type="number"
            min="10"
            max="10000"
            value={alConfig.labelingBudget}
            onChange={(e) => setALConfig(prev => ({ ...prev, labelingBudget: parseInt(e.target.value) }))}
          />
          <small>Total number of samples to be labeled</small>
        </div>

        <div className="form-group">
          <label>Max Iterations:</label>
          <input
            type="number"
            min="1"
            max="100"
            value={alConfig.maxIterations}
            onChange={(e) => setALConfig(prev => ({ ...prev, maxIterations: parseInt(e.target.value) }))}
          />
          <small>Number of Active Learning rounds</small>
        </div>

        <div className="form-group">
          <label>Validation Split:</label>
          <input
            type="number"
            min="0.1"
            max="0.5"
            step="0.05"
            value={alConfig.validationSplit}
            onChange={(e) => setALConfig(prev => ({ ...prev, validationSplit: parseFloat(e.target.value) }))}
          />
          <small>Fraction of data used for validation</small>
        </div>
      </div>

      <div className="form-group">
        <label>
          <input
            type="checkbox"
            checked={alConfig.isFederated}
            onChange={(e) => setALConfig(prev => ({ ...prev, isFederated: e.target.checked }))}
          />
          Enable Federated Learning
        </label>
        <small>Allow distributed training across multiple nodes</small>
      </div>

      <div className="al-summary">
        <h4>Active Learning Summary:</h4>
        <div className="summary-grid">
          <div>Strategy: {alConfig.queryStrategy.replace('_', ' ')}</div>
          <div>Budget: {alConfig.labelingBudget} samples</div>
          <div>Rounds: {alConfig.maxIterations}</div>
          <div>Federated: {alConfig.isFederated ? 'Yes' : 'No'}</div>
        </div>
      </div>
    </div>
  );

  const renderReviewStep = () => {
    const preview = roCrate ? dvreROCrateClient.generatePreview(roCrate) : null;
    const validation = roCrate ? dvreROCrateClient.validateROCrate(roCrate) : null;

    return (
      <div className="setup-step">
        <h3>Review & Finalize</h3>
        <p>Review your project configuration before finalizing the setup.</p>
        
        {preview && (
          <div className="project-summary">
            <h4>Project Overview:</h4>
            <div className="summary-grid">
              <div><strong>Title:</strong> {preview.title}</div>
              <div><strong>Description:</strong> {preview.description}</div>
              <div><strong>Status:</strong> {preview.status}</div>
              <div><strong>Participants:</strong> {preview.participants}</div>
              <div><strong>Datasets:</strong> {preview.datasets}</div>
              <div><strong>Workflow:</strong> {preview.hasWorkflow ? 'Configured' : 'Not configured'}</div>
            </div>
          </div>
        )}

        {validation && (
          <div className={`validation-result ${validation.valid ? 'valid' : 'invalid'}`}>
            <h4>Validation Status:</h4>
            {validation.valid ? (
              <div className="validation-success">
                ✓ Project configuration is valid and ready for deployment
              </div>
            ) : (
              <div className="validation-errors">
                <h5>Errors to fix:</h5>
                <ul>
                  {validation.errors.map((error, index) => (
                    <li key={index}>{error}</li>
                  ))}
                </ul>
              </div>
            )}
            
            {validation.warnings.length > 0 && (
              <div className="validation-warnings">
                <h5>Warnings:</h5>
                <ul>
                  {validation.warnings.map((warning, index) => (
                    <li key={index}>{warning}</li>
                  ))}
                </ul>
              </div>
            )}
          </div>
        )}

        {roCrate && (
          <div className="rocrate-export">
            <h4>RO-Crate Metadata:</h4>
            <button
              onClick={() => {
                const metadata = dvreROCrateClient.exportMetadata(roCrate);
                const blob = new Blob([metadata], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${projectId}-ro-crate-metadata.json`;
                a.click();
              }}
              className="export-button"
            >
              Download RO-Crate Metadata
            </button>
          </div>
        )}

        <div className="finalization-info">
          <h4>What happens when you finalize:</h4>
          <div className="finalization-steps">
            <div className="fin-step">
              <span className="step-icon">1</span>
              <div>
                <strong>Validate Configuration</strong>
                <p>Ensures all required fields are complete and valid</p>
              </div>
            </div>
            <div className="fin-step">
              <span className="step-icon">2</span>
              <div>
                <strong>Upload to IPFS</strong>
                <p>Stores RO-Crate metadata and workflow on decentralized storage</p>
              </div>
            </div>
            <div className="fin-step">
              <span className="step-icon">3</span>
              <div>
                <strong>Submit to Orchestrator</strong>
                <p>Registers workflow with the execution engine for Active Learning</p>
              </div>
            </div>
            <div className="fin-step">
              <span className="step-icon">4</span>
              <div>
                <strong>Update Smart Contract</strong>
                <p>Records IPFS hashes and project status on blockchain</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    );
  };

  const getStepIndex = (step: SetupStep): number => {
    const steps: SetupStep[] = ['datasets', 'model', 'workflow', 'configuration', 'review'];
    return steps.indexOf(step);
  };

  const canProceed = (): boolean => {
    switch (currentStep) {
      case 'datasets':
        return !!roCrate?.datasets.training;
      case 'model':
        return !!(modelConfig.name && modelConfig.algorithm);
      case 'workflow':
        return !!(workflowConfig.name && (workflowConfig.useTemplate || workflowConfig.customCWL));
      case 'configuration':
        return alConfig.labelingBudget > 0 && alConfig.maxIterations > 0;
      case 'review':
        return !!roCrate && dvreROCrateClient.validateROCrate(roCrate).valid;
      default:
        return false;
    }
  };

  const handleNext = () => {
    const steps: SetupStep[] = ['datasets', 'model', 'workflow', 'configuration', 'review'];
    const currentIndex = getStepIndex(currentStep);
    
    if (currentStep === 'workflow' && workflowConfig.useTemplate) {
      generateWorkflow();
    }
    
    if (currentIndex < steps.length - 1) {
      setCurrentStep(steps[currentIndex + 1]);
    }
  };

  const handlePrevious = () => {
    const steps: SetupStep[] = ['datasets', 'model', 'workflow', 'configuration', 'review'];
    const currentIndex = getStepIndex(currentStep);
    
    if (currentIndex > 0) {
      setCurrentStep(steps[currentIndex - 1]);
    }
  };

  if (!roCrate) {
    return (
      <div className="setup-wizard loading">
        <div className="loading-indicator">
          <div className="spinner"></div>
          <span>Initializing project setup...</span>
        </div>
      </div>
    );
  }

  return (
    <div className="setup-wizard">
      <div className="wizard-header">
        <h2>DAL Project Setup</h2>
        <div className="step-indicator">
          {['datasets', 'model', 'workflow', 'configuration', 'review'].map((step, index) => (
            <div
              key={step}
              className={`step ${currentStep === step ? 'active' : ''} ${
                getStepIndex(currentStep) > index ? 'completed' : ''
              }`}
            >
              <div className="step-number">{index + 1}</div>
              <div className="step-label">{step.charAt(0).toUpperCase() + step.slice(1)}</div>
            </div>
          ))}
        </div>
      </div>

      {error && (
        <div className="error-message">
          {error}
          <button onClick={() => setError(null)}>×</button>
        </div>
      )}

      <div className="wizard-content">
        {currentStep === 'datasets' && renderDatasetsStep()}
        {currentStep === 'model' && renderModelStep()}
        {currentStep === 'workflow' && renderWorkflowStep()}
        {currentStep === 'configuration' && renderConfigurationStep()}
        {currentStep === 'review' && renderReviewStep()}
      </div>

      <div className="wizard-footer">
        <button
          onClick={onCancel}
          className="cancel-button"
          disabled={loading}
        >
          Cancel
        </button>
        
        <div className="navigation-buttons">
          <button
            onClick={handlePrevious}
            disabled={getStepIndex(currentStep) === 0 || loading}
            className="nav-button previous"
          >
            Previous
          </button>
          
          {currentStep === 'review' ? (
            <button
              onClick={finalizeProject}
              disabled={!canProceed() || loading}
              className="finalize-button"
            >
              {loading ? 'Finalizing Project...' : 'Finalize & Upload to IPFS'}
            </button>
          ) : (
            <button
              onClick={handleNext}
              disabled={!canProceed() || loading}
              className="nav-button next"
            >
              Next
            </button>
          )}
        </div>
      </div>
    </div>
  );
}; 